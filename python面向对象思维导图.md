# python面向对象

## 面向对象与面相过程

### 产生背景

#### 科学计算为目标的必然产物

##### 鸡兔同笼问题

#### 软件领域的扩张和系统膨胀之后产生

### 编程方法

#### 自顶向下

#### 自底向上

### 代码主体结构

#### 程序=数据（变量）+算法（函数/过程）

#### 程序=对象+交互

### 数据操作主体

#### 由函数/过程进行加工与展现

#### 在对象的方法中加工与展现

### 模拟方法

#### 通过函数/过程操纵表现世界的数据与状态

#### 把世界描绘成具有主动性的对象之间的交互

### 编程思维

#### 搞清数据处理的步骤

#### 面向对象分析

### 运行效率

#### 速度快

#### 速度慢

## 面向对象入门

### 对象编程理解

#### PO

##### 蚂蚁吃虫子的游戏，蚂蚁一个变量，虫子一个变量

#### OO

##### 蚂蚁吃虫子，蚂蚁一个对象，虫子一个对象，地图一个对象

### 理解对象

#### 对象可以指自然界的任何事物

#### 计算机为解决某个领域问题所使用的事物（自然界中的事物模型化）

#### 事物（对象）具有自身的特征或能力

#### 计算机中的对象具有解决问题所需要的特征或能力

### 对象优越性

#### 封装

##### 将模型的特征和能力打包在一起

##### 模型的改变由模型自身来完成，想自然界的事物一样

##### 隐藏模型的细节，外界只能使用他，而不必或不能改变他

#### 继承

##### 符合自然界的分类规律

##### 快速代码重用

#### 多态

##### 子类可以继承父类的特征与能力，还可以通过自定义来修改其特征与能力

##### 鸭子类型（duck typing）

#### 组合

##### 一个模型可由其他模型组成

## 定义和使用类

### 最简单的类定义

### 类的实例化

### 类与实例之间的关系

#### 定义类就是建立事物模型（模子（印章））

#### 实例化类就是建立真实事物（印章图案）

### 有特征和能力的类

#### 特征/属性,是类自身包含或知道的数据

#### 能力，以方法体现，是类具有能动性的体现

### 实例化步骤

#### 调用__new__()方法创建实例

#### __new__()方法自动从object继承

#### 调用__init__()方法对其初始化

#### __init__()方法在类中定义

### 添加类说明

#### 紧跟类名行之后，以三引号包围的字符串

#### 查看类说明

##### 类名.__doc__

##### help（类名）

### 新式类和经典类

#### python2.x

##### 默认类为经典类

##### 继承object为新式类

#### python3.x

##### 统一为新式类，不用继承object

#### 区别

##### 经典类继承为深度优先

##### 新式类继承为广度优先

## 描述对象的特征

### 实例属性

#### 类被实例化以后才会具有的属性

#### 一般在__init__()方法中创建并初始化

#### 直接使用即定义：self.<属性名>

#### 引用方法：self.<属性名>

#### self用来代表类的实例

#### 类外用实例名.属性名方式定义和使用

#### 相同类的不同实例其实例属性是不相关的

#### 一般不建议在__init__()方法之外中创建和初始化实例属性

#### 一般不推荐类外定义和修改，修改可以单独定义方法

### 类属性

#### 类定义后就存在，而且不需要实例化

#### 类属性使得相同的类在不同的实例共同持有相同的变量

### 私有属性

#### 不提供限制属性访问的关键字，（无法限制类的各种属性在类外直接访问）

#### 使用__开头的变量名加以标识，只有类对象自己你能访问

#### 使用_开头的变量名加以标识，应该只有类对象及其子类能访问

### 特殊属性

#### 保存对象的元数据

#### __doc__

##### 类文档说明

#### __name__

##### 类名

#### __dict__

#### __module__

##### 返回模块

#### __base__

##### 返回父类

## 深入理解类的属性

### 同名的类属性与实例属性

#### 以实例名.属性名引用时，优先引用实例属性

#### 以类名.属性名引用时，只能引用类属性

### 属性访问的特殊方法（反射）

#### 提供用字符串来操作类的属性/方法的方式

#### 主要工具函数

##### hasattr(obj.name,'属性名')

##### setattr(obj.name,'属性名'，值)

##### getattr(obj.name,'属性名')

### 属性包装

#### 将方法包装成为属性，隐藏相关实现

##### 控制属性的类型或范围

##### 虚拟属性（由其他属性处理后得来）

#### 三种属性操作

##### 可读：@property

##### 可写：@<property_name>.setter

##### 可删除：@<property_name>.deleter

### 描述符

#### 将实现特殊协议方法的类作为另一个类的类属性

#### 用来拦截和控制属性访问并可以重复使用

#### 协议方法

##### __get__()

##### __set__()

##### __delete__()

#### 分类

##### 数据描述符(实现全部协议方法)

##### 非数据描述符（实现部分协议方法）

##### 说明：所有类成员函数都是非数据描述符

#### 同名的实例属性和非数据描述符（以方法为例）访问优先级

#### 注意：只能在新式类中使用

### __call__()让类的实例如函数一样可以调用

## 让对象具有能动性

### 类的方法的定义

#### def fun_name(self,....):

#### 其中的参数self代表类的实例，在调用方法是由系统自动提供

#### 方法定义时必须指明self参数

### 类的方法的调用

#### 与普通的函数调用类似

#### 在类内部调用：self.<方法名>（参数列表）

#### 在类的外部调用：实例名.<方法名>(参数列表)

#### 注：以上两种调用方法，都不需要在参数列表中提供self

### 类内方法相互调用

#### 在一个类的内部方法之间是可以相互调用的

#### 调用方法同上面所述的在类的内部调用方法

### 构造方法及其作用

#### 构造方法就是前面提到的__init__()方法

#### 构造函数的作用就是在类实例化时初始化实例

#### __init__()方法就是类实例化的第二步自动调用的函数

#### 注意其方法名是固定的，但其参数和普通方法一样，至少应带有self参数

#### 构造方法可以带有除self外的其他各种参数(关键字参数，默认参数，用元组收集参数，用字典收集参数等)：可以达到在实例化类时，为相应的属性传入指定的值

### 提醒

#### 实例方法和实例属性一样，必须在类实例化之后才可以调用

#### python3.x中，print是一个函数，在2.x中是一个语句

## 设计模式

### 装饰模式

#### 一般来说，通过继承可以获得父类的属性，还可以通过重载修改其方法

#### 装饰模式可以再不以继承的方式而动态的修改类的方法

#### 装饰模式可以再不以继承的方式而返回一个被修改的类

#### 基本实现

#### 类装饰器

## 鸭子类型与多态

### 什么是多态

#### 一种类型具有多种类型的能力

#### 允许不同的对象对同一消息作出灵活的反应

#### 以一种通用的方式对待可使用的对象

#### 费动态语言必须通过继承和接口来实现

### python中的多态

#### 通过继承实现多态（子类可以作为父类使用）

#### 子类通过重载父类的方法来实现多态

### 动态语言与鸭子类型

#### 变量绑定的类型具有不确定性

#### 函数和方法可以接受任何类型的参数

#### 调用方法时不检查提供的参数类型

#### 调用时否成功有参数的方法和属性确定

#### 调用不成功则抛出错误

#### python中不用定义接口

### 多态的好处

#### 带来极大的灵活性

## 类的继承与方法重载

### 类的继承是面向对象编程的优点之一

### 继承的特点

#### 减少代码和灵活定制新类

#### 子类具有父类的属性和方法

#### 子类不能继承父类的私有属性和方法

#### 子类可以添加新的方法

#### 子类可以修改父类的方法

### 继承的语法

#### 定义类时，在类名后：（继承的类名）

#### 多重继承时,括号中放多个类名

#### 例子：class MyClass(BaseClass)

### 重载的语法

#### 直接定义和父类同名的方法

### 修改父类方法

#### 在重载的方法中调用父类方法

#### 同时添加相应的业务逻辑

#### 多重继承时如何调用父类的方法

## 类的特殊方法

### 深入理解类

#### 类也是一个对象，但具有创建其自身实力的能力

#### 类可以和一个变量进行绑定

#### 你可以为类增加属性

#### 你可以把它作为函数的参数传递

### 元类

#### 类的创建于管理者（type）

#### 所有的类都是type元类的实例

#### 类实例化过程

##### __new__()

##### __init__()

#### 自定义元类

##### 目的：对其创建的类进行预处理

##### 继承type

##### 定义__new__()方法

##### 还可以定义__init__()方法

#### 应用元类

##### python3.x

###### 类继承中提供关键字参数：metaclass=元类名

##### python2.x

###### 定义一个模块变量__metaclass__=元类名

###### 为某个类添加类属性__metaclass__=元类名

### 构造序列

#### __len__(self)

#### __getitem__(self,key)

#### __setitem__(self,value)

#### __delitem__(self,key)

### 构造iter(可迭代对象)

#### __iter__(self)

#### __next__(self)

### 构造可比较类

#### __lt__()

#### __le__()

#### __gt__()

#### __ge__()

#### __eq__()

#### __ne__()

### 构造可运算类

#### __add__()

#### __sub__()

#### __mul__()

#### __div__()

## 类方法，静态方法

### 静态方法

#### 定义方法

##### @staticmethod装饰

##### 参数不用self

#### 访问特性

##### 不能引用或访问实例属性

##### 可以通过类，类变量访问类属性

#### 调用方法

##### 可以用类，类实例调用

#### 本质

##### 在类中的一个普通函数而已

##### 是面向对象程序中函数归属于类，易于代码管理

#### 用法

##### 与类相关，但不依赖或改变类与实例

##### 创建不同的实例

##### 把类相关工具方法放入类中

### 类方法

#### 定义方法

##### @classmethod

##### 必须提供参数cls

#### 访问特性

##### 不能引用或访问实例属性

#### 调用方法

##### 可以用类，类实例调用

#### 继承特性

##### 继承时，传入类变量cls是子类，而不是父类

#### 用途

##### 与类相关，但不依赖或改变类的实例

##### 工厂方法，创建类实例，完成有关预处理

##### 在类内调用静态方法是不用硬编码类名
